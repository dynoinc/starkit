// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package workflow

import (
	"context"
)

const getEvents = `-- name: GetEvents :many
SELECT data FROM events WHERE run_id = $1 ORDER BY version ASC
`

func (q *Queries) GetEvents(ctx context.Context, runID string) ([][]byte, error) {
	rows, err := q.db.Query(ctx, getEvents, runID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := [][]byte{}
	for rows.Next() {
		var data []byte
		if err := rows.Scan(&data); err != nil {
			return nil, err
		}
		items = append(items, data)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFirstEvent = `-- name: GetFirstEvent :one
SELECT data FROM events WHERE run_id = $1 ORDER BY version ASC LIMIT 1
`

func (q *Queries) GetFirstEvent(ctx context.Context, runID string) ([]byte, error) {
	row := q.db.QueryRow(ctx, getFirstEvent, runID)
	var data []byte
	err := row.Scan(&data)
	return data, err
}

const getLastEvent = `-- name: GetLastEvent :one
SELECT data, version FROM events WHERE run_id = $1 ORDER BY version DESC LIMIT 1
`

type GetLastEventRow struct {
	Data    []byte `json:"data"`
	Version int32  `json:"version"`
}

func (q *Queries) GetLastEvent(ctx context.Context, runID string) (GetLastEventRow, error) {
	row := q.db.QueryRow(ctx, getLastEvent, runID)
	var i GetLastEventRow
	err := row.Scan(&i.Data, &i.Version)
	return i, err
}

const getRunVersion = `-- name: GetRunVersion :one
SELECT version FROM runs WHERE id = $1
`

func (q *Queries) GetRunVersion(ctx context.Context, id string) (int32, error) {
	row := q.db.QueryRow(ctx, getRunVersion, id)
	var version int32
	err := row.Scan(&version)
	return version, err
}

const getRunVersionForUpdate = `-- name: GetRunVersionForUpdate :one
SELECT version FROM runs WHERE id = $1 FOR UPDATE
`

func (q *Queries) GetRunVersionForUpdate(ctx context.Context, id string) (int32, error) {
	row := q.db.QueryRow(ctx, getRunVersionForUpdate, id)
	var version int32
	err := row.Scan(&version)
	return version, err
}

const getScript = `-- name: GetScript :one
SELECT data FROM scripts WHERE hash = $1
`

func (q *Queries) GetScript(ctx context.Context, hash string) ([]byte, error) {
	row := q.db.QueryRow(ctx, getScript, hash)
	var data []byte
	err := row.Scan(&data)
	return data, err
}

const insertEvent = `-- name: InsertEvent :exec
INSERT INTO events (run_id, version, data)
VALUES ($1, $2, $3)
`

type InsertEventParams struct {
	RunID   string `json:"run_id"`
	Version int32  `json:"version"`
	Data    []byte `json:"data"`
}

func (q *Queries) InsertEvent(ctx context.Context, arg InsertEventParams) error {
	_, err := q.db.Exec(ctx, insertEvent, arg.RunID, arg.Version, arg.Data)
	return err
}

const putScript = `-- name: PutScript :exec
INSERT INTO scripts (hash, data)
VALUES ($1, $2)
ON CONFLICT (hash) DO UPDATE SET data = excluded.data
`

type PutScriptParams struct {
	Hash string `json:"hash"`
	Data []byte `json:"data"`
}

func (q *Queries) PutScript(ctx context.Context, arg PutScriptParams) error {
	_, err := q.db.Exec(ctx, putScript, arg.Hash, arg.Data)
	return err
}

const upsertRun = `-- name: UpsertRun :one
INSERT INTO runs (id, version)
VALUES ($1, $2)
ON CONFLICT (id) DO UPDATE SET version = excluded.version
RETURNING version
`

type UpsertRunParams struct {
	ID      string `json:"id"`
	Version int32  `json:"version"`
}

func (q *Queries) UpsertRun(ctx context.Context, arg UpsertRunParams) (int32, error) {
	row := q.db.QueryRow(ctx, upsertRun, arg.ID, arg.Version)
	var version int32
	err := row.Scan(&version)
	return version, err
}
